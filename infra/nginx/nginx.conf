worker_processes 1;

events {
    worker_connections 1024;
}

http {
    # docker DNS 사용
    resolver 127.0.0.11 valid=30s;
   
    include       mime.types;
    default_type  application/octet-stream;
    
    lua_shared_dict my_limit_req_store 50m;
    
    # app은 도커 컴포즈 서비스 이름에 맞게 수정 필요
    upstream backend {
        server app:8080;
    }
    
    server {
        listen 80;
       
        # Common Proxy Settings
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        location ~ /api/chats/[^/]+/messages {
            access_by_lua_block {
                if ngx.var.request_method == "POST" then
                    -- user_id 추출, 프록시에서 헤더 직접 사용은 보안 상 취약할 가능성
                    local headers = ngx.req.get_headers()
                    local user_id = headers["user-id"]
                    if not user_id then
                        ngx.say("missing user-id header")
                        return ngx.exit(401)
                    end
                    
                    -- fallback rate limiting
                    local limit_req = require "resty.limit.req"
                    local lim, err = limit_req.new("my_limit_req_store", 0.5, 3)
                    if not lim then
                        ngx.log(ngx.ERR,
                                "failed to instantiate a resty.limit.req object: ", err)
                        return ngx.exit(500)
                    end
                    
                    local function fallback()
                        local key = user_id
                        local delay, err = lim:incoming(key, true)
                        if not delay then
                            if err == "rejected" then
                                return ngx.exit(503)
                            end
                            ngx.log(ngx.ERR, "failed to limit req: ", err)
                            return ngx.exit(500)
                        end
                        
                        if delay >= 0.001 then
                            ngx.log(ngx.ERR, "delay is not allowed with default rate limiting")
                            return ngx.exit(429)
                        end
                    end
                    
                    local redis = require "resty.redis"
                    
                    -- 현재 Sentinel은 Redis와 동일 컨테이너
                    local sentinels = {
                        { host = "redis-master", port = 26379 },
                        { host = "redis-replica1", port = 26379 },
                        { host = "redis-replica2", port = 26379 },
                    }
                    local master_name = "mymaster"  -- sentinel.conf에서 정의한 master 이름
                    
                    -- Sentinel에서 마스터 주소 가져오기
                    local function get_master()
                        for _, s in ipairs(sentinels) do
                            local red = redis:new()
                            red:set_timeout(1000)  -- 1초 타임아웃
                            local ok, err = red:connect(s.host, s.port)
                            if not ok then
                                ngx.log(ngx.ERR, "failed to connect to sentinel ", s.host, ":", s.port, " - ", err)
                            else
                                local res, err = red:sentinel("get-master-addr-by-name", master_name)
                                if res and #res == 2 then
                                    -- res[1] = IP, res[2] = port
                                    return res[1], tonumber(res[2])
                                end
                            end
                        end
                        return nil, nil
                    end

                    -- 마스터 조회 및 연결
                    local function connect_master(retries)
                        retries = retries or 3
                        local last_err
                        for i = 1, retries do
                            local master_ip, master_port = get_master()  -- Sentinel 조회
                            if master_ip then
                                local red = redis:new()
                                red:set_timeout(1000)
                                local ok, err = red:connect(master_ip, master_port)
                                if ok then
                                    return red
                                else
                                    last_err = err
                                    ngx.log(ngx.WARN, "failed to connect master, retrying: ", err)
                                    ngx.sleep(0.1)
                                end
                            else
                                last_err = "cannot get master from sentinels"
                                ngx.sleep(0.1)
                            end
                        end
                        return nil, last_err
                    end
                    
                    local red, err = connect_master()
                    if not red then
                        ngx.log(ngx.ERR, err)
                        fallback()
                        return
                    end

                    -- 등록한 Redis Function 호출
                    local res, err = red:fcall("check_if_allowed", 0, user_id)
                    if not res then
                        ngx.log(ngx.ERR, "failed to call redis function: ", err)
                        return ngx.exit(500)
                    end
                    
                    -- 결과에 따른 반환
                    if res == 0 then return ngx.exit(429) end
                end
            }
            
            proxy_pass http://backend;
        }
        
        location /api {
            proxy_pass http://backend;
        }
    }
}
